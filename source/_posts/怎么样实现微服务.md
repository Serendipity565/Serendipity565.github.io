---
type: Post
title: 怎么样实现微服务
tags: 后端
category: 开发
category_bar: true
abbrlink: 24119
date: 2024-05-06 06:23:23
---

## **怎么具体实践微服务**

要实际的应用微服务，需要解决一下四点问题：

1、客户端如何访问这些服务

2、每个服务之间如何通信

3、如此多的服务，如何实现？

4、服务挂了，如何解决？（备份方案，应急处理机制）

### **1、客户端如何访问这些服务**

原来的Monolithic方式开发，所有的服务都是本地的，UI可以直接调用，现在按功能拆分成独立的服务，跑在独立的（一般都在独立的虚拟机上的）进程了。客户端UI如何访问他的？

后台有N个服务，前台就需要记住管理N个服务，一个服务下线/更新/升级，前台就要重新部署，这明显不服务我们 拆分的理念，特别当前台是移动应用的时候，通常业务变化的节奏更快。

另外，N个小服务的调用也是一个不小的网络开销。还有一般微服务在系统内部，通常是无 状态的，用户登录信息和权限管理最好有一个统一的地方维护管理（OAuth）。

所以，一般在后台N个服务和UI之间一般会一个代理或者叫API Gateway，他的作用包括：

① 提供统一服务入口，让微服务对前台透明

② 聚合后台的服务，节省流量，提升性能

③ 提供安全，过滤，流控等API管理功能

其实这个API Gateway可以有很多广义的实现办法，可以是一个软硬一体的盒子，也可以是一个简单的MVC框架，甚至是一个Node.js的服务端。他们最重要的作 用是为前台（通常是

移动应用）提供后台服务的聚合，提供一个统一的服务出口，解除他们之间的耦合，不过API Gateway也有可能成为单点故障点或者性能的瓶颈。

用过Taobao Open Platform（淘宝开放平台）的就能很容易的体会，TAO就是这个API Gateway。

![1](https://pic1.zhimg.com/80/v2-bf7f072ed5e24b5be391e2bf183cea0e_1440w.webp?source=1def8aca)

### **2、每个服务之间如何通信**

所有的微服务都是独立的进程跑在独立的虚拟机上，所以服务间的通信就是IPC（inter process communication），已经有很多成熟的方案。现在基本最通用的有两种方式：

同步调用：

①REST（JAX-RS，Spring Boot）

②RPC（Thrift, Dubbo）

异步消息调用(Kafka, Notify, MetaQ)

![2](https://picx.zhimg.com/80/v2-c40dab206f7d2a5c1a87d4ab7af6b280_1440w.webp?source=1def8aca)

#### **同步和异步的区别：**

一般同步调用比较简单，一致性强，但是容易出调用问题，性能体验上也会差些，特别是调用层次多的时候。RESTful和RPC的比较也是一个很有意思的话题。

一般REST基于HTTP，更容易实现，更容易被接受，服务端实现技术也更灵活些，各个语言都能支持，同时能跨客户端，对客户端没有特殊的要求，只要封装了HTTP的SDK就能调用，所以相对使用的广一些。RPC也有自己的优点，传输协议更高效，安全更可控，特别在一个公司内部，如果有统一个的开发规范和统一的服务框架时，他的开发效率优势更明显些。

而异步消息的方式在分布式系统中有特别广泛的应用，他既能减低调用服务之间的耦合，又能成为调用之间的缓冲，确保消息积压不会冲垮被调用方，同时能保证调用方的服务体验，继续干自己该干的活，不至于被后台性能拖慢。不过需要付出的代价是一致性的减弱，需要接受数据最终一致性。还有就是后台服务一般要实现幂等性，因为消息发送出于性能的考虑一般会有重复（保证消息的被收到且仅收到一次对性能是很大的考验）。最后就是必须引入一个独立的broker，如果公司内部没有技术积累，对broker分布式管理也是一个很大的挑战。

### **3、如此多的服务，如何实现？**

在微服务架构中，一般每一个服务都是有多个拷贝，来做**负载均衡**。一个服务随时可能下线，也可能应对临时访问压力增加新的服务节点。服务之间如何相互感知？服务如何管理？

这就是服务发现的问题了。一般有两类做法，也各有优缺点。基本都是通过zookeeper等类似技术做服务注册信息的分布式管理。当服务上线时，服务提供者将自己的服务信息注册到ZK（或类似框架），并通过心跳维持长链接，实时更新链接信息。服务调用者通过ZK寻址，根据可定制算法， 找到一个服务，还可以将服务信息缓存在本地以提高性能。

当服务下线时，ZK会发通知给服务客户端。

**客户端做：** 优点是架构简单，扩展灵活，只对服务注册器依赖。缺点是客户端要维护所有调用服务的地址，有技术难度，一般大公司都有成熟的内部框架支持，比如Dubbo。

**服务端做：** 优点是简单，所有服务对于前台调用方透明，一般在小公司在云服务上部署的应用采用的比较多。

![3](https://pic1.zhimg.com/80/v2-202f51a6b0e8a557ca51026655ca5cb4_1440w.webp?source=1def8aca)

### **4、服务挂了，如何解决**

前面提到，Monolithic方式开发一个很大的风险是，把所有鸡蛋放在一个篮子里，一荣俱荣，一损俱损。而分布式最大的特性就是网络是不可靠的。通过微服务拆分能降低这个风险，

不过如果没有特别的保障，结局肯定是噩梦。所以当我们的系统是由一系列的服务调用链组成的时候，我们必须确保任一环节出问题都不至于影响整体链路。相应的手段有很多：

①重试机制

②限流

③熔断机制

④负载均衡

⑤降级（本地缓存）

这些方法基本都很明确通用，比如Netflix的Hystrix：[https://github.com/Netflix/Hystrix](https://link.zhihu.com/?target=https%3A//github.com/Netflix/Hystrix)

![https://pic1.zhimg.com/80/v2-30cc410e0e6526e21a8eb1ab24d2ec2c_1440w.webp?source=1def8aca](https://pic1.zhimg.com/80/v2-30cc410e0e6526e21a8eb1ab24d2ec2c_1440w.webp?source=1def8aca)

## **常见的设计模式和应用**

有一个图非常好的总结微服务架构需要考虑的问题，包括：

1、API Gateway

2、服务间调用

3、服务发现

4、服务容错

5、服务部署

6、数据调用

![](https://pic1.zhimg.com/80/v2-c2ebe2ada517080a7d0acb79a70041f1_1440w.webp?source=1def8aca)

### **1.聚合器微服务设计模式**

这是一种最常用也最简单的设计模式，如下图所示：

![](/img/blog/zmsxwfw/1.png)

聚合器设计模式是一种设计模式，用于通过聚合多个独立的微服务的响应来组成一个复杂的服务， 它可以是一个简单的Web页面，将检索到的数据进行处理展示。它也可以是一个更高层次的组合微服务，对检索到的数据增加业务逻辑后进一步发布成一个新的微服务，这符合DRY原则。

另外，每个服务都有自己的缓存和数据库。如果聚合器是一个组合服务，那么它也有自己的缓存和数据库。聚合器可以沿X轴和Z轴独立扩展。它也是与SAGA、CQRS和EventSourcing一起的基本微服务设计模式之一。**当客户端请求需要跨多个微服务分布的数据或功能时，此模式是合适的。可以提高系统的性能和可扩展性通过允许每个微服务专注于特定任务并减少单个微服务的工作量。**

### **2.链式微服务设计模式**

这种模式在接收到请求后会产生一个经过合并的响应，如下图所示：

![](/img/blog/zmsxwfw/3.png)

在这种情况下，服务A接收到请求后会与服务B进行通信，类似地，服务B会同服务C进行通信。所有服务都使用同步消息传递。在整个链式调用完成之前，客户端会一直阻塞。因此，服务调用链不宜过长，以免客户端长时间等待。并且链式微服务设计有如下特性：

**松耦合设计**：链式微服务设计模式通过将每个微服务作为一个独立的组件，将它们按照业务需求连接在一起，实现了微服务之间的松耦合。每个微服务只需要关注自己的业务逻辑，不需要关心其他微服务的具体实现，从而提高了系统的可维护性和可扩展性。

**灵活的组合**：链式微服务设计模式可以根据业务需求灵活地组合微服务，形成不同的调用链。每个微服务可以根据自己的需要选择下一个要调用的微服务，并且可以根据需要对调用链进行动态的调整。这种灵活的组合方式可以满足不同业务场景下的需求，提高了系统的灵活性和适应性。

**异步调用**：链式微服务设计模式可以通过异步调用的方式提高系统的性能和并发能力。每个微服务可以将自己的请求发送到下一个微服务，并立即返回结果，不需要等待下一个微服务的处理结果。这样可以让系统同时处理多个请求，提高系统的吞吐量和并发处理能力。

**失败处理**：链式微服务设计模式可以通过设置失败处理策略来提高系统的可靠性。当某个微服务调用失败时，可以根据需要选择重试、回退或者忽略该请求。这样可以在一定程度上保证整个系统的稳定性和可用性。监控和追踪：链式微服务设计模式可以通过在每个微服务中添加监控和追踪的功能来提高系统的可观察性。每个微服务可以记录自己的调用信息，包括请求参数、处理时间等，并将这些信息发送到监控系统中进行统计和分析。这样可以及时发现问题并进行优化，提高系统的性能和稳定性。

综上所述，链式微服务设计模式通过将微服务按照业务需求连接在一起，实现了微服务之间的解耦和灵活的组合。它可以提高系统的可维护性、可扩展性和可观察性，同时可以提高系统的性能、并发能力和可靠性。

### **3.分支微服务设计模式**

分支微服务设计模式是一种将复杂的业务逻辑拆解为多个微服务的架构设计模式。在该设计模式中，每个微服务负责处理不同的分支逻辑，即根据不同条件或参数的取值来执行不同的业务流程。这种模式是聚合器模式的扩展，允许同时调用两个微服务链，如下图所示：

![](/img/blog/zmsxwfw/4.png)

#### **特点**

1. 解耦性高：每个分支逻辑都由单独的微服务负责处理，使得系统各个组件之间解耦，降低了系统的耦合度。
2. 可扩展性强：由于每个分支逻辑都由单独的微服务负责处理，因此可以根据业务需要独立地扩展每个分支逻辑的处理能力。
3. 灵活性高：根据不同条件或参数的取值，可以灵活地调用不同的分支微服务，以满足不同的业务需求。
4. 可维护性好：每个分支逻辑都由单独的微服务负责处理，使得系统的代码结构清晰，易于维护。

#### **注意事项**

1. 分支微服务的设计应该遵循单一职责原则，每个微服务应只负责处理一个特定的分支逻辑，避免一个微服务负责处理过多的分支逻辑。
2. 应该合理地划分分支逻辑，避免过多的分支条件，以免增加系统的复杂度和维护成本。
3. 不同分支逻辑的微服务之间应该进行合理的通信和协作，确保各个分支逻辑之间的数据一致性和业务流程的正确性。
4. 分支微服务的设计应该考虑系统的性能和可扩展性，合理地分配资源，避免某个分支逻辑的处理能力成为系统的瓶颈。
5. 在设计分支微服务时应考虑到系统的整体架构，合理地划分边界和接口，确保分支逻辑的扩展不会影响系统的整体稳定性和可靠性。

### **4.代理微服务设计模式**

代理微服务设计模式是一种常用的微服务架构模式，用于提供对其他微服务的访问和控制。该模式的核心思想是通过引入代理服务来隐藏底层微服务的复杂性，并提供额外的功能和保护。这是聚合器模式的一个变种，如下图所示：

![](/img/blog/zmsxwfw/2.png)

在这种情况下，客户端并不聚合数据，但会根据业务需求的差别调用不同的微服务。代理可以仅仅委派请求，也可以进行数据转换工作。

#### **特点**

1. 隐藏复杂性：代理微服务可以隐藏底层微服务的复杂性，对外提供简单的接口，使使用者无需了解底层微服务的实现细节。
2. 提供额外功能：代理微服务可以在底层微服务的基础上提供额外的功能，如缓存、认证、鉴权、日志等，以增强服务的功能和性能。
3. 控制访问：代理微服务可以对外部请求进行控制和管理，例如限流、熔断、降级等，以确保底层微服务的稳定性和可靠性。
4. 解耦微服务：代理微服务可以将底层微服务解耦，使得各个微服务之间的依赖关系更加清晰，易于维护和升级。

#### **注意事项**

1. 精心选择代理服务：选择合适的代理服务非常重要，需要考虑代理服务的性能、稳定性和可扩展性，以满足系统的需求。
2. 避免过度代理：过度使用代理服务可能会导致系统的复杂性增加，降低性能和可靠性，因此需要谨慎设计和选择代理服务。
3. 考虑代理服务的安全性：代理微服务通常处于系统的边界位置，需要特别注意安全性，防止被攻击或滥用。
4. 慎重使用缓存：代理微服务中的缓存功能可以提升性能，但需要注意缓存一致性和过期策略，避免数据不一致或过期数据的问题。
5. 监控和管理代理服务：代理微服务通常需要进行监控和管理，以确保其稳定运行和及时发现问题，并及时进行调整和优化。

总之，代理微服务设计模式是一种有效的架构模式，可以帮助系统实现微服务间的解耦、提供额外功能和控制访问，并需要在设计和使用时注意其特点和注意事项。

### **5.异步消息传递微服务设计模式**

异步消息传递微服务设计模式是一种架构模式，用于实现松耦合、高可扩展性和可靠性的微服务系统。在这种模式下，微服务之间通过消息队列或消息中间件进行通信，将消息作为传递机制，实现服务之间的解耦和异步通信。虽然REST设计模式非常流行，但它是同步的，会造成阻塞。因此部分基于微服务的架构可能会选择使用消息队列代替REST请求/响应，如下图所示：

![](/img/blog/zmsxwfw/6.png)

#### **特点**

1. 解耦性：异步消息传递可以将服务之间的依赖关系转化为消息的生产者和消费者之间的关系，从而实现松耦合的微服务系统。
2. 异步性：消息的发送和接收是异步的，消息生产者可以继续执行，而不必等待消息被消费。这种异步性可以提高系统的吞吐量和性能。
3. 可靠性：通过使用消息队列或消息中间件，可以保证消息的可靠传递。即使消费者服务宕机或变得不可用，消息也可以保存在队列中，等待服务恢复后继续消费。
4. 可扩展性：由于消息的异步传递，可以根据系统的负载情况动态地增加或减少消费者服务的数量，实现系统的水平扩展。
5. 解决高并发问题：通过异步消息传递，可以将请求分散到多个消费者服务中进行处理，从而提高系统的并发处理能力。

#### **注意事项**

在使用异步消息传递微服务设计模式时，需要注意以下事项：

1. 消息的顺序性：由于消息是异步传递的，不能保证消息的顺序性。在设计中需要考虑是否有必要保持消息的顺序，如果有，则需要在消息中添加序号或者使用有序消息队列。
2. 消息的幂等性：由于消息的异步性，可能会导致消息的重复消费。为了避免重复消费带来的副作用，需要在消费者服务中实现消息的幂等处理。
3. 消息的持久化：为了保证消息的可靠性，在使用消息队列或消息中间件时，需要将消息持久化到磁盘，以防止消息丢失。
4. 消息的超时处理：如果消息的消费时间过长，可能会导致消息队列中的消息积压。为了避免消息积压，需要在消费者服务中实现消息的超时处理和重试机制。
5. 异常处理和监控：在使用异步消息传递微服务设计模式时，需要实现适当的异常处理和监控机制，以便及时发现和解决消息传递过程中的问题。

综上所述，异步消息传递微服务设计模式是一种可靠、高性能、可扩展的架构模式，适用于需要解耦和提高系统吞吐量的微服务系统。但在使用时需要注意消息的顺序性、幂等性、持久化、超时处理和异常处理等问题。

### **6.数据共享微服务设计模式**

数据共享微服务设计模式是一种架构模式，旨在实现不同微服务之间有效地共享数据。在微服务架构中，每个微服务负责管理自己的数据，但有时候需要在多个微服务之间共享数据，这时候就需要使用数据共享微服务设计模式。

设计原则中自治是微服务的设计原则之一，就是说微服务是全栈式服务。但在重构现有的“单体应用（monolithic application）”时，SQL数据库反规范化可能会导致数据重复和不一致。因此，在**单体应用到微服务架构的过渡阶段，可以使用这种设计模式**，如下图所示：

![](/img/blog/zmsxwfw/5.png)

在这种情况下，部分微服务可能会共享缓存和数据库存储。不过，这只有在两个服务之间存在强耦合关系时才可以。对于基于微服务的新建应用程序而言，这是一种反模式。

#### **特点**

1. 数据共享微服务设计模式可以提高系统的灵活性和可扩展性。通过将数据共享的责任委托给专门的微服务，可以减少其他微服务之间的耦合性，使系统更易于扩展和维护。
2. 数据共享微服务设计模式可以提高数据的一致性。通过将数据共享的逻辑集中在一个微服务中，可以确保数据的一致性和准确性，避免了多个微服务之间数据不一致的问题。
3. 数据共享微服务设计模式可以提高系统的性能。通过缓存共享的数据，可以减少对底层数据源的访问次数，提高系统的响应速度和吞吐量。

#### **注意事项**

1. 在设计数据共享微服务时，需要仔细考虑数据的一致性和隔离性。不同微服务之间的数据共享可能会导致数据一致性的问题，需要通过合适的策略来解决，如使用分布式事务或事件驱动等方式。
2. 需要考虑数据共享的权限和安全性。不同微服务可能对共享数据有不同的权限和安全需求，需要在设计中考虑如何限制对共享数据的访问，并确保数据的安全性。
3. 需要考虑数据共享的性能和扩展性。不同微服务之间可能存在性能瓶颈和扩展性问题，需要通过合适的缓存机制和扩展策略来解决，以保证系统的性能和可扩展性。
4. 需要考虑数据共享的一致性维护和监控。对于共享数据的变更，需要确保及时通知到其他相关的微服务，并对数据的一致性进行监控和维护，以及时发现和解决数据一致性的问题。

## **微服务的优点和缺点**

### **1、微服务的优点：**

**关键点：** 复杂度可控，独立按需扩展，技术选型灵活，容错，可用性高

**①**它解决了复杂性的问题。它会将一种怪异的整体应用程序分解成一组服务。虽然功能总量 不变，但应用程序已分解为可管理的块或服务。每个服务都以RPC或消息驱动的API的形式定义了一个明确的边界。微服务架构模式实现了一个模块化水平。

**②**每个服务都能够由专注于该服务的团队独立开发。开发人员可以自由选择任何有用的技术。然而，这种自由意味着开发人员不再有义务使用在新项目开始时存在的可能过时的技术。在编写新服务时，他们可以选择使用当前的技术。此外，由于服务相对较小，因此使用当前技术重写旧服务变得可行。

**③**微服务架构模式使每个微服务都能独立部署。开发人员不需要协调部署本地服务的变更。这些变化可以在测试后尽快部署。

**④**每个服务都可以独立调整。可以仅部署满足其容量和可用性限制的每个服务的实例数。此外，可以使用最符合服务资源要求的硬件。

### **2、微服务的缺点**

**关键点：** 多服务运维难度，系统部署依赖，服务间通信成本，数据一致性，系统集成测试，重复工作，性能监控等

**①**一个缺点是名称本身。术语microservice过度强调服务规模。但重要的是要记住，这是一种手段，而不是主要目标。微服务的目标是充分分解应用程序，以便于敏捷应用程序开发和部署。

**②**另一个主要缺点是分布式系统而产生的复杂性。开发人员需要选择和实现基于消息传递或RPC的[进程间通信](https://www.zhihu.com/search?q=%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A860169294%7D)机制。此外，他们还必须编写代码来处理部分故障，因为请求的目的地可能很慢或不可用。

**③**微服务器的另一个挑战是分区数据库架构。更新多个业务实体的业务交易是相当普遍的。但是，在基于微服务器的应用程序中，您需要更新不同服务所拥有的多个数据库。使用分布式事务通常不是一个选择，而不仅仅是因为CAP定理。许多今天高度可扩展的NoSQL数据库都不支持它们。你最终不得不使用最终的一致性方法，这对开发人员来说更具挑战性。

**④**测试微服务应用程序也更复杂。服务类似的测试类将需要启动该服务及其所依赖的任何服务（或至少为这些服务配置存根）。再次，重要的是不要低估这样做的复杂性。

**⑤**另一个主要挑战是实现跨越多个服务的更改。例如，我们假设您正在实施一个需要更改服务A，B和C，其中A取决于B和B取决于C。在单片应用程序中，您可以简单地更改相应的模块，整合更改，并一次性部署。相比之下，在Microservice架构模式中，您需要仔细规划和协调对每个服务的更改。例如，您需要更新服务C，然后更新服务B，然后再维修A。幸运的是，大多数更改通常仅影响一个服务，而需要协调的多服务变更相对较少。

**⑥**部署基于微服务的应用程序也更复杂。单一应用程序简单地部署在传统负载平衡器后面的一组相同的服务器上。每个应用程序实例都配置有基础架构服务（如数据库和消息代理）的位置（主机和端口）。相比之下，微服务应用通常由大量服务组成。例如，每个服务将有多个运行时实例。更多的移动部件需要进行配置，部署，扩展和监控。此外，您还需要实现服务发现机制，使服务能够发现需要与之通信的任何其他服务的位置（主机和端口）。

## **思考**

微服务对我们的思考，更多的是思维上的转变。对于微服务架构：**技术上不是问题，意识比工具重要。**

关于微服务的几点设计出发点：

1、应用程序的核心是业务逻辑，按照业务或客户需求组织资源（这是最难的）

2、做有生命的产品，而不是项目

3、全栈化

4、后台服务贯彻Single Responsibility Principle（[单一职责原则](https://www.zhihu.com/search?q=%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A860169294%7D)），一个类改变的原因不应该超过一个，一个类应该专注于单一功能。

5、VM->Docker

6、DevOps（DevOps是一组过程、方法与系统的统称，用于促进 **开发**、**技术运营** 和 **质量保障（QA）** 部门之间的沟通、协作与整合。）

有这么多的中间件和强大的PE支持固然是好事，但是我们也需要深入去了解这些中间件背后的原理，知其然知其所以然，在有限的技术资源如何通过开源技术实施微服务？

最后，一般提到微服务都离不开DevOps和Docker，**理解微服务架构是核心，devops和docker是工具，是手段。**
